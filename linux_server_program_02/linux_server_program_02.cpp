// linux_server_program_02.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//IP协议
// 是TCP/IP协议族底层动力，为上层提供无状态、无连接、不可靠服务
// IP数据报发送、传输和接收都是相互独立、没有上下文关系，无法处理乱序和重复数据报
// 只要收到了完整的数据，就解协议头后交给上层
// TCP协议能够自己处理乱序和重复报文段，并将正确的内容有序传给上层
// IP数据报头部虽然有标识字段，但是被用来处理分片和重组，而不表示接受顺序
// 简单、高效
// UDP和HTTP也是无状态协议
// 无连接指双方不长久维持对方信息，每次发送数据都需要指明对方IP
// 不可靠指IP数据报可能发送失败，并通知上层，tcp会根据自己的机制重传
//

//
//IPv4
// 头部长度通常为20字节，包含
// 4位版本号 4位头部长度 8位服务类型  16位总长度（字节数）
// 16位标识                           3位标志    13位片偏移
// 8位生存时间TTL    8位协议          16位头部校验和
// 32位源IP地址
// 32位目的端地址
// （其他选项，最多40字节）
// 
// 版本号 协议版本，IPv4值为4
// 头部长度 表示IP头有多少个4字节，4位最大值15，所以最长为60
// 服务类型 包含3位优先权字段、5位TOS、1位保留
// 总长度 16位最大65535字节，但长度超过MTU的要分片
// 标识 唯一标识一个数据报，每发送一个包则+1，若分片，则每个分片相同
// 标志 第一位保留，第二位DF禁止分片，第三位MF更多分片
// 偏移 分片相对于原始IP数据报的偏移
// 生存时间 TTL，数据报到达目的地之前允许经过的路由器跳数，常见值64，每经过一个路由-1，到0时丢弃，向源发送ICMP差错报文，防止路由循环
// 协议 区分上层协议，ICMP值1，TCP值6，UDP值17等
// 校验和 CRC检查IP数据报头（仅头）是否损坏
// 源和目的地址标识发送接收端，整个数据报传递中，无论经过多少路由都保持不变
//

//
//IP分片
// MTU限制最大长度为1500，超过则分片传输
// 传输中，可能在发送端发生，也可能在中转路由分片，最终只在目标机器被IP模块重组
// 主要依赖于三个字段 数据报标识、标志和片偏移
//

//
//IP路由
// IP协议核心任务是数据报路由，主要流程
//  IP模块收到来自链路层的IP数据报，校验头部CRC，分析头信息
//  如果是发送给本机的数据报，则根据头部中协议字段提交给TCP/UDP等上层协议
//  如果设置了源站选路（松散源路由选择或严格源路由选择）或不是本机的数据报，则调用转发子模块
//  转发子模块首先检测系统是否允许转发，不允许则丢弃，允许则交给输出子模块
//  数据报发送给哪个下一跳路由，以及经过哪个网卡发送，根据路由表决定
//  之后数据被放到等待发送的IP数据报输出队列
// 
//路由机制
// route命令可以查看路由表
/*

[root@centos-linux ~]# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         prl-local-ns-se 0.0.0.0         UG    102    0        0 eth0
10.37.129.0     0.0.0.0         255.255.255.0   U     101    0        0 eth1
10.211.55.0     0.0.0.0         255.255.255.0   U     102    0        0 eth0
192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0

*/
// Flags为路由项标志，常见标志5种，U为活动，G为目标是网关，H为目标是主机，D为由重定向生成，M为被重定向修改过
// Metric为路由距离，到达目标网络的中转数
// ref为被引用次数，use为被使用次数
// Iface为对应的输出网卡接口
// 第一项目标地址为default，为默认路由项，包含G标志，表示下一跳为网关
// 
//数据报匹配
// 查找路由表中和数据报目标IP地址完全匹配的主机IP，找到则用该项，没有则
// 查找路由表中和数据报目标IP具有相同网路ID的网络IP地址，找到则使用该项，没有则
// 选择默认路由项
// 
//路由表更新
// route add -host 192.168.1.xxx dev ethn
// route del -net 192.168.1.0 netmask 255.255.255.0
// route del default
// route add default gw 192168.1.109 dev ethn
// 通过route修改路由表是静态路由更新方式
// 对于大型路由器，通常经过BGP（边际网关协议）、RIP、OSPF等协议发现路径，更新路由，是动态、自动的
//

//
//IP转发
// 不是发送给本机的IP数据报都由转发子模块处理，路由器可以执行转发，而主机一般只接收和发送
// 对于Linux，在/proc/sys/net/ipv4/ip_forward内核参数默认设置为0，可以修改它使主机开启转发功能
// echo 1 > /proc/sys/net/ipv4/ip_forward
// 
//对于允许IP数据报转发的系统，执行如下操作
// 检查TTL，为0则丢弃
// 检查头部严格源路由选择项，如果被设置则检测目标IP是否使本机某IP，不是则发送ICMP源站选路失败报文给发送端
// 如果有必要，给源端发送一个ICMP重定向报文，告诉它更合理的下一跳
// 将TTL减1
// 处理IP头
// 如有必要，执行IP分片
//

//
//重定向
// ICMP重定向报文，用于更新路由表
// /proc/sys/net/ipv4/conf/all/send_redirects内核参数指定是否允许发送ICMP重定向报文
// 一般来说，主机只能接收，路由器只能发送
//

//
//IPv6
// IPv4一个大问题是即使用了NAT等技术，地址仍然可能不够用
// 除了解决这一问题，v6协议增加了多播和流、引入自动配置功能、增加了网络安全功能等
// 头部结构
// 4位版本号 指定IP协议版本，值6
// 8位通信类型 指示数据流通信类型或优先级，类似v4的TOS
// 20位流标签 新增字段，用于某些对链接由特殊要求的通信，如音频或视频等实时数据
// 16位净荷长度 扩展头部和应用数据长度和，不包括固定头长度
// 8位下一个包头 指出紧跟v6固定头部之后的包头类型，如扩展头或某个上层协议头（TCP/UDP/ICMP）类似v4的协议字段
// 8位跳数限制 与v4的TTL同义
// 128位源IP地址和128位目的IP地址，用:号分割为8组，每组两字节，0可以压缩（仅一次）
//

int main()
{
    std::cout << "Hello World!\n";
}
