// linux_server_program_02.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//IP协议
// 是TCP/IP协议族底层动力，为上层提供无状态、无连接、不可靠服务
// IP数据报发送、传输和接收都是相互独立、没有上下文关系，无法处理乱序和重复数据报
// 只要收到了完整的数据，就解协议头后交给上层
// TCP协议能够自己处理乱序和重复报文段，并将正确的内容有序传给上层
// IP数据报头部虽然有标识字段，但是被用来处理分片和重组，而不表示接受顺序
// 简单、高效
// UDP和HTTP也是无状态协议
// 无连接指双方不长久维持对方信息，每次发送数据都需要指明对方IP
// 不可靠指IP数据报可能发送失败，并通知上层，tcp会根据自己的机制重传
//

//
//IPv4
// 头部长度通常为20字节，包含
// 4位版本号 4位头部长度 8位服务类型  16位总长度（字节数）
// 16位标识                           3位标志    13位片偏移
// 8位生存时间TTL    8位协议          16位头部校验和
// 32位源IP地址
// 32位目的端地址
// （其他选项，最多40字节）
// 
// 版本号 协议版本，IPv4值为4
// 头部长度 表示IP头有多少个4字节，4位最大值15，所以最长为60
// 服务类型 包含3位优先权字段、5位TOS、1位保留
// 总长度 16位最大65535字节，但长度超过MTU的要分片
// 标识 唯一标识一个数据报，每发送一个包则+1，若分片，则每个分片相同
// 标志 第一位保留，第二位DF禁止分片，第三位MF更多分片
// 偏移 分片相对于原始IP数据报的偏移
// 生存时间 TTL，数据报到达目的地之前允许经过的路由器跳数，常见值64，每经过一个路由-1，到0时丢弃，向源发送ICMP差错报文，防止路由循环
// 协议 区分上层协议，ICMP值1，TCP值6，UDP值17等
// 校验和 CRC检查IP数据报头（仅头）是否损坏
// 源和目的地址标识发送接收端，整个数据报传递中，无论经过多少路由都保持不变
//

//
//IP分片
// MTU限制最大长度为1500，超过则分片传输
// 传输中，可能在发送端发生，也可能在中转路由分片，最终只在目标机器被IP模块重组
// 主要依赖于三个字段 数据报标识、标志和片偏移
//

//
//IP路由
// IP协议核心任务是数据报路由，主要流程
//  IP模块收到来自链路层的IP数据报，校验头部CRC，分析头信息
//  如果是发送给本机的数据报，则根据头部中协议字段提交给TCP/UDP等上层协议
//  如果设置了源站选路（松散源路由选择或严格源路由选择）或不是本机的数据报，则调用转发子模块
//  转发子模块首先检测系统是否允许转发，不允许则丢弃，允许则交给输出子模块
//  数据报发送给哪个下一跳路由，以及经过哪个网卡发送，根据路由表决定
//  之后数据被放到等待发送的IP数据报输出队列
// 
//路由机制
// route命令可以查看路由表
/*

[root@centos-linux ~]# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         prl-local-ns-se 0.0.0.0         UG    102    0        0 eth0
10.37.129.0     0.0.0.0         255.255.255.0   U     101    0        0 eth1
10.211.55.0     0.0.0.0         255.255.255.0   U     102    0        0 eth0
192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0

*/
// Flags为路由项标志，常见标志5种，U为活动，G为目标是网关，H为目标是主机，D为由重定向生成，M为被重定向修改过
// Metric为路由距离，到达目标网络的中转数
// ref为被引用次数，use为被使用次数
// Iface为对应的输出网卡接口
// 第一项目标地址为default，为默认路由项，包含G标志，表示下一跳为网关
// 
//数据报匹配
// 查找路由表中和数据报目标IP地址完全匹配的主机IP，找到则用该项，没有则
// 查找路由表中和数据报目标IP具有相同网路ID的网络IP地址，找到则使用该项，没有则
// 选择默认路由项
// 
//路由表更新
// route add -host 192.168.1.xxx dev ethn
// route del -net 192.168.1.0 netmask 255.255.255.0
// route del default
// route add default gw 192168.1.109 dev ethn
// 通过route修改路由表是静态路由更新方式
// 对于大型路由器，通常经过BGP（边际网关协议）、RIP、OSPF等协议发现路径，更新路由，是动态、自动的
//

//
//IP转发
// 不是发送给本机的IP数据报都由转发子模块处理，路由器可以执行转发，而主机一般只接收和发送
// 对于Linux，在/proc/sys/net/ipv4/ip_forward内核参数默认设置为0，可以修改它使主机开启转发功能
// echo 1 > /proc/sys/net/ipv4/ip_forward
// 
//对于允许IP数据报转发的系统，执行如下操作
// 检查TTL，为0则丢弃
// 检查头部严格源路由选择项，如果被设置则检测目标IP是否使本机某IP，不是则发送ICMP源站选路失败报文给发送端
// 如果有必要，给源端发送一个ICMP重定向报文，告诉它更合理的下一跳
// 将TTL减1
// 处理IP头
// 如有必要，执行IP分片
//

//
//重定向
// ICMP重定向报文，用于更新路由表
// /proc/sys/net/ipv4/conf/all/send_redirects内核参数指定是否允许发送ICMP重定向报文
// 一般来说，主机只能接收，路由器只能发送
//

//
//IPv6
// IPv4一个大问题是即使用了NAT等技术，地址仍然可能不够用
// 除了解决这一问题，v6协议增加了多播和流、引入自动配置功能、增加了网络安全功能等
// 头部结构
// 4位版本号 指定IP协议版本，值6
// 8位通信类型 指示数据流通信类型或优先级，类似v4的TOS
// 20位流标签 新增字段，用于某些对链接由特殊要求的通信，如音频或视频等实时数据
// 16位净荷长度 扩展头部和应用数据长度和，不包括固定头长度
// 8位下一个包头 指出紧跟v6固定头部之后的包头类型，如扩展头或某个上层协议头（TCP/UDP/ICMP）类似v4的协议字段
// 8位跳数限制 与v4的TTL同义
// 128位源IP地址和128位目的IP地址，用:号分割为8组，每组两字节，0可以压缩（仅一次）
//



//
//TCP协议
// 比IP协议更靠近应用层，许多重要socket选项都与TCP协议相关
// 面向连接、字节流、可靠传输
// 双方必须为连接分配必要内核资源，建立连接后才能开始数据读写
// 采用应答机制，每发送一个报文段都必须得到应答才认为发送成功
// 采用超时重传，若定时器时间内未收到应答则重发
// IP数据报可能乱序重复，TCP对接收的报文进行重排整理
// 全双工，一对一，完成数据交换后断开连接释放资源
// 基于广播和多播的应用则不适合TCP，应选用UDP
//

//
//头部结构
// 固定头长度20字节
// 16位源端口和16位目的端口，用于区分服务
// 32位序号，一次TCP通信中一个传输方向上的字节流编号，第一个报文被初始化为随机值ISN，后续报文段设置程ISN加上第一个字节在整个字节流中的偏移
// 32位确认号，用作另一方发来的TCP报文段响应，其值为序号值+1
// 4位头部长度，表示头部有多少个4字节，4位最大15，所以头长最多60
// 6位保留
// 6位标志位
//  URG，表示紧急指针是否有效
//  ACK，表示确认号是否有效；携带ACK标志的报文段为确认报文段
//  PSH，提示接收端应用程序应该立即从TCP接收缓冲区读走数据
//  RST，表示要求对方重新建立连接；携带RST的报文段为复位报文段
//  SYN，表示请求建立一个连接；携带SYN的报文段为同步报文段
//  FIN，表示通知对方本端要关闭连接了；为结束报文段
// 16位窗口大小，用于TCP流量控制，告诉对方，自己的接收缓冲区还有多少空余，对方可以控制发送数据的速度
// 16位校验和，CRC校验报文段是否损坏（包括头部和数据部分）
// 16位紧急指针，与序号字段值相加表示最后一个紧急数据的下一字节序号，是一个偏移量
// 
// 可变选项，最大长度40字节
//

//
//TCP建立和关闭
// 第一个报文包含SYN标志，发起连接请求，携带一个序号 n 
// 对方回复一个SYN报文段，同时携带ACK标志，表示确认，确认值为n+1，并且发送自己的序号m
// 前两个包不携带应用数据
// 得到确认后，第三个报文段是本端对对方的确认报文，携带ack，确认值为m+1
// 自此连接建立，称为3次握手
// 
// 关闭连接时
// 一端向另一端发送FIN报文，对端返回一个ack确认
// 两方都只是表示自己断开，所以是分别发送，总共四个报文段
// 即4次挥手
// 
//半关闭
// TCP是全双工，允许两个方向数据传输独立关闭
// 通信一方发送FIN给对方，告诉本端不会再发送数据，但允许继续接收
// 直到对方也发送FIN报文段关闭连接，这种状态为half close
// 判断对方已经关闭连接的方法是，read返回0，收到结束报文段
// socket接口中shutdown函数提供了半关闭的支持
// 
//连接超时
// 网络繁忙可能进行重连
// 超时判断时间动态调整，一般是1s、2s、4s、8s、16s
// 重试多次后，放弃连接，通知应用
//

//
//TCP状态转移
// 一个连接任意一端在任意时刻都处于某种状态
// 
// 服务器上
// listen调用后进入LISTEN状态，等待客户端连接
// 监听到某个连接请求，即收到SYN报文，回复SYN,ACK确认报文，该连接此时处于SYN_RCVD
// 当再次收到客户端ACK确认报文，该连接转为ESTABLISHED状态，双方可以进行数据传输
// 客户端主动关闭连接时，即收到FIN，服务器返回确认报文，连接进入CLOSE_WAIT
// 通常，检测到客户端关闭后，也会立即给客户端发送FIN报文，连接进入LAST_ACK状态，客户端确认后，连接彻底关闭
// 客户端上
// connect连接目标后，发送SYN报文，连接进入SYN_SENT状态，可能失败，两个原因
//  连接端口不存在，或端口处于TIME_WAIT状态，则服务器回复RST
//  端口存在但在超时时间内未收到确认报文，则失败
// 失败后，连接返回CLOSED状态
// 成功则进入ESTABLISHED状态
// 客户端主动关闭，向服务端发送FIN，进入FIN_WAIT_1状态
// 收到确认报文后，进入FIN_WAIT_2状态，与此同时，服务器处于CLOSE_WAIT，至此是半关闭
// 当服务器也发送FIN，客户端进行确认并进入TIME_WAIT状态（如果在FIN_WAIT_1状态直接收到同时带有确认和FIN的报文，则跳过FIN_WAIT_2直接进入TIME_WAIT）
// 
//TIME_WAIT
// 客户端连接收到最终的服务器结束报文后，并不是直接进入CLOSED状态，而是转移到TIME_WAIT状态
// 在这个状态一般要等待2MSL（报文最大生存时间，一般为2min）才会完全关闭
// 其存在原因
//  可靠地终止TCP连接（若服务端地结束报文段过来后，确认报文丢失，则服务器会重发FIN，若不等待，则客户端为关闭状态，回复RST，会被服务端认为是错误）
//  保证让迟来地TCP报文段有足够时间被识别和丢弃
// 
// 而TIME_WAIT状态在高并发服务中是并不希望存在的，此状态会一直占用端口
// 可以通过设置socket选项SO_REUSEADDR来强制进程立即使用处于TIME_WAIT占用的端口
//

//
//RST报文
// 产生复位报文段的几种原因
//  访问不存在的端口，目标主机直接回复RST（处于TIME_WAIT的端口也是）
//  异常终止连接
//  处理半打开连接，通信一端关闭或异常终止了连接，而对方没有收到结束报文，另一端还维持着连接；向半打开连接写入数据会得到RST回复
//

//
//带外数据
// OOB，有些传输层协议有此概念
// 比普通数据有更高优先级，总是应该立即被发送
// 使用很少见，telnet、ftp等用到了
//

//
//拥塞控制
// /proc/sys/net/ipv4/tcp_congestion_control指示了机器当前使用的拥塞控制算法
// 发送端需要合理选择SWND（发送窗口）
// 接收方可通过其收到的对端RWND（接收窗口）来控制发送窗口
// 发送端还引入了CWND（拥塞窗口）
// 
//慢启动和拥塞避免
// TCP模块刚开始发送数据不知道实际情况，用一种试探方式平滑增加CWND大小
// 慢启动有一个阈值，当CWND大小超过阈值，则进入拥塞避免阶段 
//

int main()
{
    std::cout << "Hello World!\n";
}
