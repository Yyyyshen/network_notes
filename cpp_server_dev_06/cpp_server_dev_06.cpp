// cpp_server_dev_06.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>
#include <vector>

//
//网络通信协议设计
//

//
//理解TCP
// 流式协议，内容之间无明确分解标志
// A与B进行TCP通信，发送长度为100和200两个包，接收时可能以任意长度的多个包总共收到300的数据
// 若不定义协议格式确定把多少数据作为合法数据，则在局域网和公网的复杂网络环境下，难以确认数据完整
// 例如，发送端连续发送多次字符串，接收端循环接收打印时，可能出现不完整、乱码等情况（printf以\0作为结束，若填满接收数组，可能会读取越界出现乱码）
//

//
//粘包问题
// 网络通信时常见问题
// 粘包、丢包、乱序
// TCP场景下，是可靠通信，丢包和乱序基本不存在
// UDP下，需要自己在UDP基础上实现类似TCP传输机制（RTP、RUDP）
// 
// 所以，大部分场景中，需要处理的就是粘包问题
// 即收到的数据包为半个、多个的情况
// 
//常见方式
// 固定包长数据包，接收够每满定长数据则解析，收到部分就先存起来；灵活性差
// 以指定字符（串）作为包结束标志，FTP和SMTP在命令或数据结尾加上 \r\n(CRLF) 表示一个包结束
// 包头+包体方式，约定好固定长度包头，包头中至少包含一个长度字段说明包体长度（或包含包头长度）
//

//
//解包与处理
// 收到数据 -> 当前数据是否达到包头大小 -是-> 解析包头数据 -> 剩余字节数是否足够包体大小 -是-> 解析包得到业务数据 -> 循环处理
// （不满足大小时缓存数据，继续接收）
// 
// 包头定义
#pragma pack(push,1)		//将结构体数据强制以固定长度字节数对齐；网络包头中常用1字节对齐
struct msg_header
{
	uint32_t bodysize;		//包体大小
	//uint8_t cmd;			//常见携带命令号的包头协议
};
#pragma pack(pop)
#define MAX_PACK_SIZE 50000	//约定最大包体长度
// 解包方式
std::vector<char> read_buf;	//利用vector自动管理的机制和方便的成员函数，替换char数组
void
on_read()					//读到数据后的处理函数
{
	while (true)
	{
		if (read_buf.size() < (size_t)sizeof(msg_header))
			return;			//不足包头长度，返回，继续读

		msg_header head;	//准备解析包头
		memcpy(&head, &read_buf[0], sizeof(msg_header));

		if (head.bodysize <= 0
			|| head.bodysize > MAX_PACK_SIZE);
		{					//验证包头信息，不合法则关闭
			/* closesocket */
			return;
		}

		if (read_buf.size() < (size_t)head.bodysize + sizeof(msg_header))
			return;			//缓冲区不足整个包大小，返回继续读

		/* 清缓冲区中包头 */

		std::string body;	//准备解析包体
		body.append(&read_buf[0], head.bodysize);

		/* 清缓冲区中包体 */

		/* 处理业务 */
		{
			/* 验证数据合法性，非法则应该主动关闭连接 */
		}
		
	}						//循环处理粘包
}
// 
//

//
//协议演化
// 定义好的协议需要修改或升级的场景下
//	对协议struct的修改涉及到兼容性问题，旧的客户端已经在线上运行，新的协议格式可能导致旧版无法使用
//	所以设计之初，可以添加版本号字段，但频繁修改会增加代码复杂度
//	实际开发中应当尽量考虑周全，避免反复修改协议
//	另外，对于字符串类型字段，用定长传并不方便（可以增加字段，说明长度，这样不会浪费空间，但还是不够灵活）
// 
// Type Length Value，TLV协议格式
// 在每个字段前面增加一个char类型，用不同数值代表不同的常用基本数据类型
// 这样每个字段类型就可以自解释
// 缺陷是
//	每个字段都做个标记，占用空间变大
//	解析时每次要额外增加判断type逻辑，比较麻烦
//	只是做到了技术上的自解释，字段含义还是需要制定格式
// （感觉用的不多）
// 
// 说到底还是协议双方的约定
// 
// 协议分类
//	文本协议，内容人为可读，HTTP包头部分和FTP为典型
//	二进制协议
// 
// 协议设计工具
//	约定协议后每次都需要有重复的编码
//	出现了一种叫IDL（Interface Description Language）的语言规范
//	是一种描述语言，将使用类型规范化，提供跨语言特性
//	GOOGLE的Protobuf库为典型
//

//
//最大化节约字节
// 设计协议时，整型最常用，应尽量选择自己需要的位数包含要传递的信息
// 例如只需要不到100的数值，就没必要使用32位int，可以选用int8_t或char
// 甚至1字节的数据中的8位也可以充分利用，比如tcp中，有一个字节的8位就是作为了8个标志（syn,ack...）
// 
// 整型压缩
// 对于确实需要大数值的字段，也可以进行压缩
// 例，一个大数字 16843009 二进制为 00000001 00000001 00000001 00000001
// 对于每个字节8位，高位都是用0填充，因此可以根据这个性质压缩
// 这样一个int32_t可以最低压缩至1字节（最高5字节，因为要做一些标志约定压缩方式）
// POCO C++库中就有这样的整型压缩算法
// 

//
//设计协议注意事项
// 按一字节对齐 
//	结构体中，对齐方式与最大字节数的类型有关
//	可以使用#pragma pack(push, n)让包含在内的结构体强行按一字节对齐，最后用#pragma pack(pop)恢复之前对齐方式
//	这样可以使内存紧凑，节省空间
// 
// 显示指定整型长度
//	不同字长的机器上，int、long这类整型长度可能不同
//	一般使用int32_t,uint8_t，这样明确知道位数的整型类型
// 
// 浮点数精度
//	计算机处理浮点数可能存在精度取舍不准确
//	一般会放大相应倍数，直接作为整型传输
//	也可以转为字符串传输
// 
// 大小端
//	使用统一字节序，避免出现问题
// 
// 协议与升级
//	保证升级后协议兼容新旧版本
//	对于大版本的更新，应当强制客户端更新
//

//
//包分片
// 一个包数据较大，或者传输大文件时，需要将包进行分片
// 例，需要包分片的协议头定义
#pragma pack(push,1)
struct pkg_head
{
	uint8_t flag;	//起始标志
	uint8_t ver;	//版本
	uint8_t encrypt;//加密标志
	uint8_t frag;	//是否分片
	uint16_t len;	//总长
	uint16_t cmd;	//命令号
	uint16_t crc;	//crc16校验
	uint32_t sid;	//会话id
	uint16_t total;	//分片总数
	uint16_t seq;	//当前包分片序号
};
#pragma pack(pop)
// 
//

//
//XML和JSON
// 常用文本数据格式，很多第三方解析库
//

//
//HTTP
// [GET/POST] [URL路径] [HTTP协议号]\r\n
// [head]: [value]\r\n
// ...
// \r\n
// [body]
// 
// 结合SSL，也就是HTTPS，更安全
// 
// 传输大文件时，使用chunk编码技术
//	原理时将包体分为多个小块，每个包都有字段说明自身长度
//	收到这些块后拼接一下就得到完整内容了
//	[chunksize]\r\n[chunkdata]\r\n[chunksize]\r\n[chunkdata]\r\n...
// 
// 长短连接问题
//	一般都说是短链接，但可以设置keep alive字段，就不会请求后立马断开
// 
//第三方库
// libcurl 跨平台http C/C++库
//

//
//SMTP、POP3、IMAP
// 邮件协议
//

//
//WebSocket
// 用于解决HTTP通信的无状态、短链接（通常）和服务端无法主动向客户端推送数据等问题开发的协议
// TCP三次握手后，进行一次额外握手
// 发送一个GET HTTP/1.1报文，包含一些websocket特定头字段
// 相应一个状态码为 101的报文 表示切换为ws协议
// 之后通信双方的协议格式都为自定义ws格式
//

int main()
{
	std::cout << "Hello World!\n";
}
