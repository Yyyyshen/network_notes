// linux_server_program_06.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//并发支持
//

//
//多进程
//

//
//fork
// 创建新进程
// pid_t fork(void);
// 每次调用返回两次（堆栈复制后fork存在于两个进程中），父进程中返回子进程PID，子进程中返回0
// 返回值是后续代码判断当前进程是父进程还是子进程的依据
// 
// fork复制当前进程，在内核进程表创建一个新的表项，很多属性与源进程相同（堆指针、栈指针和标志寄存器）
// 子进程代码与父进程完全相同，还会复制数据
// 数据的复制是写时复制，即只有任意进程对数据写操作时，复制才会发生（缺页中断后操作系统给子进程分配内存并复制父进程数据）
// 所以，涉及到内存分配，fork应注意避免没必要的数据复制
// 
// 父进程打开的fd默认在子进程中也是打开的，fd的引用计数+1（根目录、当前工作目录等变量引用计数均+1）
//

//
//exec系列函数
// 有时需要在子进程执行其他程序，替换当前进程映像
// int exec*(const char* path, const char* arg, ...);
// 参数path指定可执行文件的路径，arg可变参数传递给新程序的main函数
// 
// 一般没有返回，除非出错
// 调用成功后，函数之后的代码都不会执行了，此时程序已被exec指定的程序代替（但不会关闭打开的fd）
//

//
//处理僵尸进程
// 多进程程序中，父进程一般需要跟踪子进程退出状态
// 子进程结束运行时，内核不会立即释放进程表表项，目的是让还在运行的父进程对子进程退出信息的查询
// 在子进程结束到父进程读取其退出状态之前这段时间，子进程处于僵尸态
// 或者子进程正常运行，父进程结束，此时子进程PPID被设置为1，即init进程接管，等待子进程结束，在它退出之前，也是僵尸态
// 
// 为避免僵尸进程产生或使子进程僵尸态结束，可用函数
// pid_t wait(int* stat_loc);
// pid_t waitpid(pid_t pid, int* stat_loc, int options);
// 函数wait将阻塞进程，直到某个子进程结束运行，返回结束运行的子进程pid，并将退出状态信息存储在参数stat_loc指向的内存中
// 有一系列宏帮助解释stat_val
// 但阻塞特性不适用于服务器，而waitpid解决了这个问题，参数options为WNOHANG时，函数调用是非阻塞的
// pid指定的子进程没结束则立即返回0，退出了就返回PID
// 
// 对于非阻塞调用，应该在事件已经发生后调用才效率最高，需要得知某子进程何时退出
// 某个进程结束时，会给父进程发送SIGCHLD信号
// 可以在父进程中捕获信号，并在信号处理函数中调用waitpid函数，彻底结束子进程
//

//
//管道
// pipe常用于进程内部通信，也可用于父进程和子进程通信
// 能够使用管道在父子进程间传递数据是基于fork机制，调用后两个管道fd都保持打开
// 一对管道只能保证进程间一个方向的数据传输，如果要双向传输，需使用两个管道（可用socketpair建立全双工管道）
//

//
//信号量
// 
//信号量原语
// 多进程访问系统某资源时，要考虑同步问题，确保任一时刻只有一个进程拥有独占式访问
// 这段对共享资源访问的代码称为临界区
// 一些从语言角度（无须内核支持）的解决并发问题的方案是忙等待，即不断等待内存某位置状态变化，CPU利用率较低
// 
// 信号量是一种特殊变量，只能取自然数值并且只支持两种操作：wait和signal
// 在linux中，这两种操作常称为 P、V操作
// P(SV) 若SV大于0，则-1，值为0，则挂起进程执行 （进入临界区操作）
// V(SV) 如果有其他进程因为等待SV而挂起，唤醒之，如果没有SV+1 （退出临界区）
// 信号量取值可以是任何自然数，最常用的是二进制信号量，只能取0和1
// 
//semget
// 创建一个新的信号量集，或获取一个已存在信号量集
// int semget(key_t key, int num_sems, int sem_flags);
// 参数key为一个键值，标识一个全局唯一的信号量集，可用相同的键值获取该信号量
// num_sems指定信号集中信号数量（如果是获取已存在的集，可传0）
// sem_flags指定一组标志，低端9bit是该信号量权限（与open的mode参数含义相同）
// 调用成功返回一个正整数，是信号量集的标识符
// 
// 创建信号集时，与之关联的内核数据结构semid_ds被创建初始化
// 
//semop
// 改变信号量的值，即执行PV操作
// 几个内核变量
// unsigned short semval;   //信号量值
// unsigned short semzcnt;  //等待信号量值变0的进程数量
// unsigned short semncnt;  //等待信号值增加的进程数量
// pid_t sempid;            //最后一次执行semop操作的进程ID
// 
// int semop(int sem_id, struct sembuf* sem_ops, size_t num_sem_ops);
// struct sembuf
// {
//      unsigned short int sem_num; //信号集中信号量的编号
//      short int sem_op;           //操作类型
//      short int sem_flg;          //影响操作的行为，如IPC_NOWAIT表示无论是否操作成功都立即返回（非阻塞），SEM_UNDO在进程退出时取消本次操作
// }
// 
//semctl
// 让调用者对信号量直接进行控制
// int semctl(int sem_id, int sem_num, int command, ...);
// 
//IPC_PRIVATE
// 值为0，在semget调用时可给key参数传递此特殊值
// 无论该信号量是否已经存在，都将创建一个新的信号量
// 使用该键值创建的信号量并非进程私有
// 可以用作父子进程之间
// 
// 例：父子进程之间使用一个IPC_PRIVATE信号量同步
// linux_src/ipc_private_sig_test.cpp
//

int main()
{
    std::cout << "Hello World!\n";
}
