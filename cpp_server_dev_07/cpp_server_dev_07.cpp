// cpp_server_dev_07.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//服务基本结构
// （前面的知识性讲解都是能直接搜到的，但还算比较细致
//  本章原本是比较期待的设计和原理性的内容，却都是文字理论。。）
//

//
//高效网络通信设计原则
// 尽量少等待
// 解决问题
//  如何检测新客户端连接进来
//  如何接收客户端连接请求
//  如何检测客户端是否发送数据进来
//  如何收取客户端发送的数据
//  如何检测客户端异常，如何处理
//  如何向客户端发送数据
//  如何关闭连接
// 基本函数
//  bind、listen、accept、recv、send
// 对于I/O复用
//  select、poll、epoll
// 
// 会阻塞的操作
//  recv没有收到数据时
//  tcp窗口不够大时send
//  connect发起连接时
//  
// 减少无用功时间
// I/O复用函数分级
//  第一级 select、poll
//  本质还是主动查询一组句柄是否有网络事件，并循环执行，若没有事件则是在做无用功
//  第二级 WSAAsyncSelect、WSAEventSelect、IOCP、epoll
//  从主动查询变为被动通知，网络事件发生时，系统通知我们处理；这就比第一级少做一些误用操作
// 并且，I/O复用中某个socket失效时应该及时移除该socket，否则可能浪费检测周期
// 
// 高效做法
//  socket设置非阻塞模式
//  使用epoll_wait管理句柄
//  检测到监听socket有EPOLLIN事件，调用accept就不会阻塞
//  将accept返回的新socket也设置为非阻塞，添加到epoll_wait管理列表
//  在有可读事件中调用recv，收到异常事件时关闭socket
//  对于写事件，LT模式下，不能开始就注册检测事件，否则会频繁触发
//  一般做法是，先直接尝试发送，成功就是成功
//  不成功或发送了一部分，则缓存剩余数据并注册写事件，触发写事件则继续发送，完全发送完则移除写事件检测
//  
// 主动关闭和被动关闭
//  检测到非法数据则应主动关闭，防止攻击
//  检测到连接异常（EPOLLERR、send/recv返回0）则一般是对端断开，需要被动关闭
// 
// 长链接，短链接
//  http:keepalive
//

//
//原始服务器架构
// socket->bind->listen->loop(accept->recv->send)
// 每轮循环处理一个客户端，不支持并发
// 
//一个连接对应一个线程模型
// 为每个客户端的连接创建一个线程，支持了并发
// 但不支持高并发，当线程太多时，cpu切换浪费了太多效率
// 
//Reactor模式
// C/C++ libevent
// Java Netty
// Python Twisted
// 都是反应器模式
// 
// 在I/O请求到达后，服务处理程序使用I/O复用技术同步地将这些请求发给处理程序
// 解决了请求太多，资源太少的问题
// 一个对外服务，接收地输入输出请求可能非常多，而处理程序资源有限
// 多路复用器将这些远远大于资源数量的输入输出请求分发
// 
// 模块
//  资源请求
//  多路复用及事件分发
//  事件处理
// 
//One thread one loop思想
// 一个网络线程对应一个循环
// 每个循环做同样的事
//  利用I/O复用检测读写事件
//  处理事件
//  业务及其他事
// 对于监听socket
//  读事件一般就认为事接受新连接
//  将新连接的socket绑定到复用函数中
// 对于普通socket
//  一般就是接收数据，解包
//  业务处理
//  应答
// 
// 线程分工
//  线程A监听，accept产生socket，并传递（往往是主线程）
//  线程B1、B2...Bn处理这些新连接的I/O事件（工作线程）
// 
// I/O复用函数的超时时间
//  若设置0，没有事件时，循环是空转
//  若设置大于0，会等待，后续任务不能及时执行
//  我们要的效果是，没有事件不空转，等待网络事件期间，有其他任务能立刻响应
// 一般的做法是
//  设置一定的超时事件，并采取一种唤醒机制
//  例如epoll_wait，不管epollfd上有没有socket fd，都挂载一个特殊的fd（wakeup fd）
//  当有其他任务需要处理，在这个唤醒fd上随便写入1字节，则epoll_wait立刻唤醒被返回
//  没有任务，也没有网络I/O事件时，wait函数就挂在那什么都不做
// 唤醒机制实现
//  linux
//      管道，pipe，将管道一端绑定到epollfd，需要唤醒时向另一端写入1字节
//      2.6新增eventfd，调用函数创建fd后绑定到epollfd上，需要唤醒时写入1字节
//      socketpair，创建一段互相连接的socket，使用方法一样
//  windows
//      对于select，由于只支持绑定SOCKET类型，所以只能模仿linux的socketpair创建两个socket
// 
// 效率保障
//  除了I/O复用函数存在等待可能，其他任何步骤都没有阻塞或耗时操作
// 
// （不得不吐槽，前面大量篇幅的使用类讲解还会配一些代码示例
// 从这一节重点的模式、原理性知识反而都是文字理论，越来越觉得，内容配不上书名，并且还有很多重复内容）
//

//
//收发数据正确做法
// 服务端产生一个新的clientfd之后
//  绑定到相应I/O复用函数并监听可读事件
//  触发后，读取数据，接收完数据的标志时recv返回-1，错误码errno为EWOULDBLOCK
//  LT模式，直接发送，数据未发送则缓存并注册写事件，完全发送完再移除写事件
// 
// 不要多线程处理一个socket，难处理也没必要
//  多线程上传下载则不同，是另一种设计
//  原理是文件分块，然后多个连接分别处理，之后按分块时的编号重新组包，本质还是每个线程处理自己的块
//

//
//发送、接收缓冲区设计
// 网络通信层与业务层应解耦
// TCP流式协议一次性不一定能收完完整包大小
// 发送则是因为tcp窗口不够大时缓存为能成功发送的数据
// 基于这些原因，需要设计缓冲区
// 
// 一般设计成内存连续的存储容器
// 固定的char数组无法确认容量大小，太小不够用，太大浪费
// 一般要设计成动态扩容的结构（std::vector<char>)
//

//
//网络库分层设计
// Session
//  业务层，不涉及网络连接
// Connection
//  每一路客户端连接对应一个conn对象，提供收发及其处理函数
// Channel
//  持有socket句柄，管理事件监听，实际进行数据收发
// Socket
//  对基本函数根据不同系统的差异性进行跨平台封装
// 
// 综合各层对象，一个socket值对应一个channel对象、一个conn对象和一个session对象
// 每一路连接只属于一个loop，只属于一个线程
// 而一个线程反过来可以拥有多个连接信息
//

//
//定时器设计
// 最简单
//  开一个线程，while循环中sleep一段时间并做一件事（sleep可换成I/O复用函数）
// 基本思路
//  定时器对象结构：唯一标识、过期时间、触发次数、回调函数
//  定时器管理，将每个定时器放在容器中，提供增加、移除、判断是否到期等操作函数
//  存在问题：每次检测时需要遍历，可以按到期时间排序，这样从最小的开始检测，如果没到期，后面的都略过
//

//
//处理业务是否单开线程
// 业务层发送数据时，不应该直接涉及send类函数调用
// 应该是存放到一个区域（队列）
// 网络线程从中读取并发送出去
//

int main()
{
    std::cout << "Hello World!\n";
}
