// linux_server_program_01.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//《Linux高性能服务器编程》
//

//
//TCP/IP协议
//

//
/*  协议族群

	应用层             ping    telnet  OSPF    DNS
						 |       |      |       |              用户空间
	---------------------|-------|------|-------|-------------------------- socket
						 |       |      |       |              内核空间
	传输层               |      TCP     |      UDP
						 |         \    |     /
	网络层             ICMP             IP
										|
	数据链路层            ARP------Data Link-----RARP
															   物理媒介
*/
//

//
//数据链路层
// 实现网卡接口的网络驱动，处理数据在物理媒介上的传输
// 不同物理网络具有不同电气特性，网络驱动隐藏了细节，为上层协议提供统一接口
// 
//两个常用协议 ARP和RARP 
// 网络层使用IP寻址一台机器，数据链路层使用物理地址（MAC）寻址一台机器
// 这两个协议实现了IP地址和机器物理地址（MAC）的转换
//

//
//网络层
// 实现数据包的选路和转发
// 广域网通过众多分级路由连接分散的主机或局域网
// 通信两台主机一般是通过多个中间节点连接而不是直接相连
// 网络层任务就是选择这些中间节点，确定通信路径
// 对上层隐藏了网络拓扑连接细节，使在上层看来通信双方是直接相连
// 
//ICMP
// Internet Control Message Protocol
// 是IP协议的重要补充，主要用于检测网络连接
// 结构： 8位类型 - 8位代码 - 16位CRC校验和
// ping程序使用ICMP查看目标是否可达（类型值为8）
// 8位代码用于细分条件、校验和为整个报文（包括头部和内容）的循环冗余校验
//

//
//传输层
// 为两台主机上的应用程序提供端到端通信
// 只关心通信起始和目的端，不在乎数据包中转过程
// 
//TCP
// 可靠面向连接和基于流的服务
// 使用超时重传、数据确认等方式确保发送正确
// 
//UDP
// 不可靠，无连接，基于数据报
// 数据在中途丢失或目的端校验发现数据错误将其丢失，只是简单通知发送失败
// 通常需要自己处理数据确认、重传等逻辑
// 每个数据报都有一个长度，接收端必须以该长度为最小单位将其内容一次性读出
// 
//SCTP
// 为了在因特网上传输电话信号而设计
//

//
//应用层
// 处理应用程序逻辑，数据由内核空间通过其他层传递
// 
//常用
// ping 利用ICMP检测网络连接
// telnet 远程登录协议，可连接到其他服务
// OSPF（Open Shortest Path First，开放最短路径优先）一种动态路由更新协议，用于路由器之间告知对方各自信息
// DNS（Domain Name Service，域名服务）提供机器域名到IP地址的转换
// 
//应用层可以跳过传输层直接使用网络层服务，比如ping和OSPF
//通常使用TCP和UDP（主要是DNS域名解析）
//

//
//封装
// 应用层数据沿着协议栈从上到下传递，每层在上一层基础上添加自己的头部信息
// |-------------------------------------------------------|
// | 以太网头 | IP头 | TCP/UDP头 | 应用程序数据 | 以太网尾 |
// |-------------------------------------------------------|
// 					 |←     TCP/UDP数据报    →|
// 			  |←     IP数据报 46~1500字节    →|	MTU
// |←				  以太网帧 64~1518字节    →|
// 
//TCP为双方维持连接，在内核中存储数据（发送、接收缓冲区）
// 发送端应用使用send/write向TCP连接写入数据，先从数据从应用层复制到内核发送缓冲区
// 之后TCP模块拼接头部信息和缓冲区中数据，传递给IP模块
//UDP传递过程类似，不同的是不需要保存数据副本，发送后直接丢弃
// 如果重发，则重新从应用层拷贝到内核层发送缓冲区并发送
//经过IP层封装的数据为IP数据报，接下来通过数据链路层封装成帧，例如以太网帧
// | 目的物理地址 | 源物理地址 | 类型 | 数据 | CRC |
// 6+6+2总共14字节的帧头，帧的最大传输单元为MTU，表示一个帧最多携带的上层协议数据
// 

//
//解复用 demultiplexing
// 帧到达目的主机，沿着协议栈自底向上传递，各层协议负责处理头部数据
// 最终处理结果交给目标应用程序
// 
//IP、ARP、RARP使用帧传递数据，所以需要帧头部某字段来确认类型
// 以太网帧用2字节类型字段标识上层协议，例如0x800表示为IP数据报，0x806表示为ARP报文
//ICMP、TCP、UDP使用IP协议，同样用IP头部的16位协议字段区分
// 1为ICMP，6为TCP、17为UDP
//应用层通过TCP/UDP等协议头部中的端口号区分
// 常用53为DNS，http为80，https为443等
//

//
//ARP原理
// IP地址到以太网MAC的转换
// 主机向自己所在网络广播一个ARP该请求包含目标地址网络地址
// 此网络其他主机都会收到，但只有被请求机器会回应ARP应答，，包含自己物理地址
// 
//以太网ARP报文格式
// | 硬件 2 | 协议 2 | 硬件地址长度 1 | 协议地址长度 1 | 操作 2 | 发送端以太网地址 6 | 发送端IP地址 4 | 目的端以太网地址 6 | 目的端IP地址 4 |
// 例：| 1表示以太网MAC | 0x800表示IP | MAC地址长为6 | IPv4协议地址长为4 | 1为ARP请求操作，2为回复操作 | 后四个字段为双方以太网和IP地址值 |
// 总长28字节，加以太网帧头14字节，总长42（如果有尾部，+4，有些实现还要求总长至少64字节，需要填充一些字节）
// 
//ARP高速缓存
// 其中包含经常访问（网关）或最近访问的机器的IP地址到物理地址映射
// 避免重复请求，提高效率
// linux下可以使用arp命令查看和修改 arp -a（查看） 、 -d（删除） 、 -s（添加）
//

//
//DNS原理
// 通常使用一个域名来访问目标机器，而不是直接使用IP
// 域名查询可以将域名转为IP，可使用NIS、DNS和本地host
// DNS是一套分布似乎域名服务，每台服务器存放大量域名和IP映射
// 报文格式
// | 标识ID 2 | 标志 2 | 问题个数 2 | 应答资源记录个数 2 | 授权资源记录数 2 | 额外资源记录数 2 | 查询问题 | 应答 | 授权 | 额外信息 |
// 标识负责将一对查询应答对应，标志的16位拆分成n个字段表示一些属性，接下来四个数量字段记录最后4个字段的资源记录数目，最后是可变长度的查询和应答
// 查询问题格式
// | 查询名 Name 可变 | 查询类型 Type 2 | 查询类 Class 2 |
// 查询名为域名，类型有A（值1）获取A记录也就是IP地址，CNAME（值5）获取别名，PTR（值12）反向查询，查询类通常为IN（值1），表示获取IP
// 应答格式与查询格式基本一致，但name字段经过压缩，域名在报文中第二次出现时，只用两个字节来保存
// 第一个字节最高两位都是1 ，余下部分和第二个字节组合在一起，表示域名第一次出现时在报文中的偏移量。通过这个偏移量，就可以找到对应的域名
// 
//Linux下的DNS服务
// cat /etc/resolv.conf 该文件存储了DNS服务器的IP地址
// host -t A www.baidu.com 该命令可查询域名对应IP（-t A 表示类型为A记录）
//

//
//Socket和TCP/IP协议族的关系
// 数据链路层、网络层、传输层协议在内核中实现，操作系统需要提供一组系统调用使应用程序访问这些协议
// 实现这组系统调用的API主要有两套 socket 和 XTI（基本不再使用）
// socket提供的功能
//	将应用程序数据从用户缓冲区复制到内核发送缓冲区，send/write
//	从内核缓冲区复制数据到用户缓冲区，以读取数据， recv/read
//	对各层协议的某些头部信息或属性进行设置，setsockopt等
// 是一套通用的网络编程接口，除了TCP/IP，可以访问其他网络协议栈（X.25、UNIX本地域协议栈等）
//

int main()
{
	std::cout << "Hello World!\n";
}
